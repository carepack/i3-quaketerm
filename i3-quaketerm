#!/usr/bin/env python3
#  Copyright (c) 2017, David Hauweele <david@hauweele.net>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#
#   1. Redistributions of source code must retain the above copyright notice, this
#      list of conditions and the following disclaimer.
#   2. Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
#  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
#  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import getopt
import signal
import shlex
import sys
import os

from collections import deque

import i3ipc

VERSION="0.1-git"

def show(i3, ws, name, position, ratio):
    verbose("show %s window" % (name,))

    x, y = ws["rect"]["x"], ws["rect"]["y"]
    w, h = ws["rect"]["width"], ws["rect"]["height"]

    h_ = int(h * ratio)
    if position == "bottom":
        y = y + h - h_
    h = h_

    i3.command("[instance=%s],"
               "resize set %d px %d px,"
               "move absolute position %d px %d px" % (name, w, h, x, y))

def hide(i3, name):
    verbose("hide %s window" % (name,))
    i3.command("[instance=%s] floating enable, move scratchpad" % (name,))

def find_instanced(con, instance, r = []):
    """Find a container by instance.
    The find_*() method from i3ipc did not return foating nodes
    correctly. So we reimplemented it here.
    """
    result = []

    q = deque(con.nodes)
    while q:
        con = q.popleft()
        if con.window_instance == instance:
            result.append(con)
        q.extend(con.nodes)
        q.extend(con.floating_nodes)

    return result

def find(i3, name):
    tree = i3.get_tree()
    term = find_instanced(tree, name)

    if len(term) == 0:
        return None
    return term[0]

def version():
    print("i3-quaketerm v%s" % (VERSION,))

def usage(name):
    print("usage: %s [OPTIONS]" % (name,))
    print("""
  -h, --help          Show this help message
  -V, --version       Show version information
  -v, --verbose       Be more verbose
  -H, --hidden        Hide terminal when created (default: false)
  -t, --terminal      Terminal emulator to use (default: xterm)
  -n, --name          Name of the terminal (WM_CLASS) (default: i3-quaketerm)
  -N, --name-options  Option used to change the name on terminal emulator (default: -name)
  -e, --extra-options Extra options passed to the terminal
  -p, --position      Position of the quaketerm (top or bottom, default: top)
  -r, --ratio         Height over width ratio (default: 0.25)""")

if __name__ == '__main__':
    progname = os.path.basename(sys.argv[0])
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hVHt:n:N:e:vp:r:", [ "help", "version", "hidden",
                                                                       "terminal=", "name=", "name-option=",
                                                                       "extra-options=", "verbose", "position=",
                                                                       "ratio=" ])
    except getopt.GetoptError as e:
        print(str(e))
        usage(progname)
        sys.exit(1)

    global verbose
    verbose       = lambda *a : None
    hidden        = False
    terminal      = "xterm"
    name          = "i3-quaketerm"
    name_option   = "-name"
    extra_options = []
    position      = "top"
    ratio         = 0.25
    for o, a in opts:
        if o in ("-v", "--verbose"):
            verbose = print
        elif o in ("-V", "--version"):
            version()
            sys.exit(0)
        elif o in ("-h", "--help"):
            usage(progname)
            sys.exit(0)
        elif o in ("-H", "--hidden"):
            hidden = True
        elif o in ("-t", "--terminal"):
            terminal = a
        elif o in ("-n", "--name"):
            name = a
        elif o in ("-N", "--name-option"):
            name_option = a
        elif o in ("-e", "--extra-options"):
            extra_options = shlex.split(a)
        elif o in ("-p", "--position"):
            position = a
            if position not in ("top", "bottom"):
                sys.exit("error: invalid position (use top or bottom)")
        elif o in ("-r", "--ratio"):
            try:
                ratio = float(a)
            except ValueError:
                sys.exit("error: invalid ratio")
        else:
            assert False, "unhandled option"

    i3 = i3ipc.Connection()
    focused_ws = [w for w in i3.get_workspaces() if w["focused"]][0]

    term = find(i3, name)
    if term:
        verbose("%s window found in tree" % (name,))

        hide(i3, name)
        if term.workspace().name != focused_ws.name:
            show(i3, focused_ws, name, position, ratio)
    else:
        verbose("%s window not found, create it" % (name,))

        # Wait for the newly created terminal to appear.
        def new_window(self, event):
            if event.container.window_instance == name:
                hide(i3, name)
                if not hidden:
                    show(i3, focused_ws, name, position, ratio)
                sys.exit(0)
        i3.on("window::new", new_window)

        # The child returning without a window appearing
        # means that an error occured.
        def sig_chld(signum, frame):
            verbose("child returned without a window")
            sys.exit(1)
        signal.signal(signal.SIGCHLD, sig_chld)

        pid = os.fork()
        if pid == 0:
            try:
                os.execvp(terminal, [terminal, name_option, name] + extra_options)
            except Exception as e:
                sys.exit("error: cannot execute terminal: " + str(e))
            assert False, "exec failed"
        i3.main()
